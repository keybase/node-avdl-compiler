// Generated by IcedCoffeeScript 108.0.11
(function() {
  var BaseEmitter, path_lib, pkg;

  path_lib = require('path');

  pkg = require('../package.json');


  /*
  An Emitter is a class that can transform a json ast from an avdl file to generated code in a language.
  
  Each emitter supports a single language, and should be named of the form `LanguageEmitter` (e.g., GoEmitter, PythonEmitter, etc.)
  BaseEmitter is an abstract base class that every emitter should inherit from. It should never be instantiated directly.
   */

  exports.BaseEmitter = BaseEmitter = (function() {
    function BaseEmitter() {
      if (this.constructor === BaseEmitter) {
        throw new Error("Can not construct abstract class.");
      }
      this._code = [];
      this._tabs = 0;
    }

    BaseEmitter.prototype.tab = function() {
      return this._tabs++;
    };

    BaseEmitter.prototype.untab = function() {
      return this._tabs--;
    };

    BaseEmitter.prototype.tabs = function() {
      var i;
      return ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this._tabs; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push(this._tab_char);
        }
        return _results;
      }).call(this)).join("");
    };

    BaseEmitter.prototype.output = function(line, _arg) {
      var frag;
      frag = (_arg != null ? _arg : {}).frag;
      if (this._last_frag) {
        this._code[this._code.length - 1] += line;
        this._last_frag = false;
      } else {
        this._code.push(this.tabs() + line);
      }
      if (frag) {
        return this._last_frag = true;
      } else {
        if ((line === "}" || line === ")") && this._tabs === 0) {
          return this._code.push("");
        }
      }
    };


    /*
    Runs the emitter.
    
    `run` takes 4 arguments:
     - `infiles`: An array of strings. Each element is the path to an input file.
     - `outfile`: The file to output.
     - `json`: A representation of our abstract syntax tree
     - `options`
       - `types_only`: Whether just types or types and interfaces should be generated
    
    Returns an array of strings, with each element corresponding to the ith line of the output code.
     */

    BaseEmitter.prototype.run = function(_arg) {
      var infiles, json, options, outfile;
      infiles = _arg.infiles, outfile = _arg.outfile, json = _arg.json, options = _arg.options;
      if (options == null) {
        options = {};
      }
      infiles.sort();
      this.emit_preface(infiles, json, options);
      this.emit_imports(json, outfile, options);
      this.emit_types(json);
      if (!options.types_only) {
        this.emit_interface(json);
      }
      return this._code;
    };


    /*
    Emits a preface to the generated file noting information such as the output language, package name, input files, and version of the compiler.
    
    Arguments:
     - `infiles`: An array of strings. Each element is the path to an input file
     - `json`: A representation of our abstract syntax tree
     - `options`
       - `types_only`: Whether just types or types and interfaces should be generated
     */

    BaseEmitter.prototype.emit_preface = function(infiles, json, _arg) {
      var types_only;
      types_only = _arg.types_only;
      throw new Error("emit_preface should be implemented by the child class");
    };


    /*
    Emits a preface to the generated file noting information such as the output language, package name, input files, and version of the compiler.
    
    Arguments:
     - `json`: A representation of our abstract syntax tree
     - `outfile`: A string representing the output file
     - `types_only`: Whether just types or types and interfaces should be generated
     */

    BaseEmitter.prototype.emit_imports = function(json, outfile, _arg) {
      var types_only;
      types_only = _arg.types_only;
      throw new Error("emit_imports should be implemented by the child class");
    };


    /*
    Emits all types defined in the input avro file.
    
    Arguments:
     - `json`: A representation of our abstract syntax tree
     */

    BaseEmitter.prototype.emit_types = function(_arg) {
      var type, types, _i, _len, _results;
      types = _arg.types;
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        _results.push(this.emit_type(type));
      }
      return _results;
    };


    /*
    Emit a single type.
    
    Arguments:
     - `type`: A representation of our type in the abstract syntax tree
     */

    BaseEmitter.prototype.emit_type = function(type) {
      var nostring;
      this.output_doc(type.doc);
      switch (type.type) {
        case "record":
          if (type.typedef) {
            return this.emit_typedef(type);
          } else {
            return this.emit_record(type);
          }
          break;
        case "fixed":
          return this.emit_fixed(type);
        case "enum":
          nostring = type.go === "nostring";
          return this.emit_enum(type, nostring);
        case "variant":
          return this.emit_variant(type);
        default:
          throw new Error("Unrecognized type: " + type);
      }
    };


    /*
    Output any documentation comments associated with a type.
    
    Arguments:
     - `doc`: The doc string that should be emitted.
     */

    BaseEmitter.prototype.output_doc = function(doc) {
      throw new Error("output_doc should be implemented by the child class");
    };


    /*
    Emit a type alias.
    Ref: https://avro.apache.org/docs/current/spec.html#Aliases
    
    Arguments:
     - `type`: The type object that should be emitted.
     */

    BaseEmitter.prototype.emit_typedef = function(type) {
      throw new Error("emit_typedef should be implemented by the child class");
    };


    /*
    Emit a record/object.
    Ref: https://avro.apache.org/docs/current/spec.html#schema_record
    
    Arguments:
     - `type`: The type object that should be emitted.
     */

    BaseEmitter.prototype.emit_record = function(type) {
      throw new Error("emit_record should be implemented by the child class");
    };


    /*
    Emit a fixed length field.
    Ref: https://avro.apache.org/docs/current/spec.html#Fixed
    
    Arguments:
     - `type`: The type object that should be emitted.
     */

    BaseEmitter.prototype.emit_fixed = function(type) {
      throw new Error("emit_fixed should be implemented by the child class");
    };


    /*
    Emit an enum.
    Ref: https://avro.apache.org/docs/current/spec.html#Enums
    
    Arguments:
     - `type`: The type object that should be emitted.
     */

    BaseEmitter.prototype.emit_enum = function(type) {
      throw new Error("emit_enum should be implemented by the child class");
    };


    /*
    Emits a variant.
    
    Variants are a custom Keybase extension to AVDL. See the below link for details.
    https://github.com/keybase/client/blob/master/protocol/docs/variants.md
    
    Arguments:
     - `type`: The type object that should be emitted.
     */

    BaseEmitter.prototype.emit_variant = function(type) {
      throw new Error("emit_variant should be implemented by the child class");
    };


    /*
    Emit all functions defined in the input file(s).
    
    Arguments:
     - `json`: A representation of our abstract syntax tree
     */

    BaseEmitter.prototype.emit_interface = function(_arg) {
      var doc, messages, protocol;
      protocol = _arg.protocol, messages = _arg.messages, doc = _arg.doc;
      throw new Error("emit_interface should be implemented by the child class");
    };

    return BaseEmitter;

  })();

}).call(this);
