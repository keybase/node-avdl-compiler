// Generated by IcedCoffeeScript 108.0.11
(function() {
  var BaseEmitter, GoEmitter, fs, is_one_way, make_esc, minimist, path_lib, pkg,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  minimist = require('minimist');

  path_lib = require('path');

  fs = require('fs');

  make_esc = require('iced-error').make_esc;

  BaseEmitter = require('./base_emitter').BaseEmitter;

  pkg = require('../package.json');

  is_one_way = function(d) {
    return (d.notify != null) || d.oneway;
  };

  exports.GoEmitter = GoEmitter = (function(_super) {
    __extends(GoEmitter, _super);

    function GoEmitter() {
      GoEmitter.__super__.constructor.apply(this, arguments);
      this._tab_char = '\t';
      this._pkg = null;
      this._default_compression_type = "none";
    }

    GoEmitter.prototype.go_translate_identifier = function(_arg) {
      var exported, go_field_suffix, name;
      name = _arg.name, go_field_suffix = _arg.go_field_suffix, exported = _arg.exported;
      if (exported) {
        return this.go_export_case(name, {
          go_field_suffix: go_field_suffix
        });
      } else if (go_field_suffix != null) {
        return name + go_field_suffix;
      } else {
        return name;
      }
    };

    GoEmitter.prototype.go_export_case = function(n, _arg) {
      var go_field_suffix, ret;
      go_field_suffix = (_arg != null ? _arg : {}).go_field_suffix;
      ret = n[0].toUpperCase() + n.slice(1);
      ret = this.go_lint_capitalize(ret);
      if (go_field_suffix != null) {
        ret += go_field_suffix;
      }
      return ret;
    };

    GoEmitter.prototype.go_lint_capitalize = function(n) {
      n = n.replace(/pgp/g, "PGP");
      n = n.replace(/Pgp/g, "PGP");
      return n;
    };

    GoEmitter.prototype.go_package = function(n) {
      return n.replace(/[.-]/g, "");
    };

    GoEmitter.prototype.go_primitive_type = function(m) {
      var map;
      map = {
        boolean: "bool",
        bytes: "[]byte",
        long: "int64",
        float: "float32",
        double: "float64"
      };
      return map[m] || m;
    };

    GoEmitter.prototype.go_compression_type = function(m) {
      var map;
      map = {
        none: "rpc.CompressionNone",
        gzip: "rpc.CompressionGzip",
        msgpackzip: "rpc.CompressionMsgpackzip"
      };
      return map[m] || m;
    };

    GoEmitter.prototype.is_primitive_switch_type = function(m) {
      return m === "boolean" || m === "long" || m === "int";
    };

    GoEmitter.prototype.append_to_last = function(s) {
      return this._code[this._code.length - 1] += s;
    };

    GoEmitter.prototype.output_doc = function(d) {
      var line, _i, _len, _ref, _results;
      if (d != null) {
        _ref = d.split(/\n/);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          _results.push(this.output("// " + line.replace(/^\s*/, '')));
        }
        return _results;
      }
    };

    GoEmitter.prototype.make_map_type = function(_arg) {
      var key, t;
      t = _arg.t;
      key = t.keys != null ? this.emit_field_type(t.keys).type : "string";
      return ("map[" + key + "]") + this.emit_field_type(t.values).type;
    };

    GoEmitter.prototype.emit_field_type = function(t, _arg) {
      var optional, optionalkey, pointed, type, _ref;
      _ref = _arg != null ? _arg : {}, pointed = _ref.pointed, optionalkey = _ref.optionalkey;
      optional = !!pointed || optionalkey;
      type = (function() {
        if (typeof t === 'string') {
          return this.go_primitive_type(t);
        } else if (typeof t === 'object') {
          if (Array.isArray(t)) {
            if (t[0] == null) {
              optional = true;
              return "*" + this.emit_field_type(t[1]).type;
            } else {
              throw new Error("Unrecognized type");
            }
          } else if (t.type === "array") {
            return "[]" + this.emit_field_type(t.items).type;
          } else if (t.type === "map") {
            return this.make_map_type({
              t: t
            });
          } else {
            throw new Error("Unrecognized type");
          }
        } else {
          throw new Error("Unrecognized type");
        }
      }).call(this);
      if (pointed) {
        type = "*" + type;
      }
      return {
        type: type,
        optional: optional
      };
    };

    GoEmitter.prototype.emit_typedef_deep_copy = function(_arg) {
      var receiver, t, type;
      t = _arg.t;
      type = t.name;
      receiver = "o";
      this.output("func (" + receiver + " " + type + ") DeepCopy() " + type + " {");
      this.tab();
      this.output("return ", {
        frag: true
      });
      this.deep_copy({
        t: t.typedef,
        val: receiver,
        exported: true
      });
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_typedef = function(t) {
      this.output("type " + t.name + " " + (this.emit_field_type(t.typedef).type));
      this.emit_typedef_deep_copy({
        t: t
      });
      return true;
    };

    GoEmitter.prototype.codec = function(_arg) {
      var jsonkey, mpackkey, name, omitempty, optional;
      name = _arg.name, optional = _arg.optional, jsonkey = _arg.jsonkey, mpackkey = _arg.mpackkey;
      omitempty = optional ? ",omitempty" : "";
      if (jsonkey == null) {
        jsonkey = name;
      }
      if (mpackkey == null) {
        mpackkey = name;
      }
      return "`codec:\"" + mpackkey + omitempty + "\" json:\"" + jsonkey + omitempty + "\"`";
    };

    GoEmitter.prototype.emit_field = function(_arg) {
      var cols, exported, go_field_suffix, jsonkey, mpackkey, name, optional, optionalkey, pointed, type, _ref;
      name = _arg.name, type = _arg.type, go_field_suffix = _arg.go_field_suffix, exported = _arg.exported, optionalkey = _arg.optionalkey, pointed = _arg.pointed, jsonkey = _arg.jsonkey, mpackkey = _arg.mpackkey;
      _ref = this.emit_field_type(type, {
        pointed: pointed,
        optionalkey: optionalkey
      }), type = _ref.type, optional = _ref.optional;
      cols = [
        this.go_translate_identifier({
          name: name,
          go_field_suffix: go_field_suffix,
          exported: exported
        }), this.go_lint_capitalize(type)
      ];
      if (exported) {
        cols.push(this.codec({
          name: name,
          optional: optional,
          jsonkey: jsonkey,
          mpackkey: mpackkey
        }));
      }
      return this.output(cols.join("\t"));
    };

    GoEmitter.prototype.emit_record = function(obj, _arg) {
      var go_field_suffix, no_deep_copy, _ref;
      _ref = _arg != null ? _arg : {}, go_field_suffix = _ref.go_field_suffix, no_deep_copy = _ref.no_deep_copy;
      this.emit_record_struct({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
      if (!no_deep_copy) {
        return this.emit_record_deep_copy({
          obj: obj,
          go_field_suffix: go_field_suffix
        });
      }
    };

    GoEmitter.prototype.emit_record_struct = function(_arg) {
      var f, go_field_suffix, obj, _i, _len, _ref;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      this.output("type " + (this.go_export_case(obj.name)) + " struct {");
      this.tab();
      if (obj.layout === 'array') {
        this.output(["_struct", "bool", "`codec:\",toarray\"`"].join("\t"));
      }
      _ref = obj.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        this.emit_field({
          name: f.name,
          type: f.type,
          go_field_suffix: go_field_suffix,
          exported: !(f.internal != null),
          optionalkey: f.optional,
          jsonkey: f.jsonkey,
          mpackkey: f.mpackkey
        });
      }
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.deep_copy = function(_arg) {
      var exported, t, val;
      t = _arg.t, val = _arg.val, exported = _arg.exported;
      if (!exported) {
        return this.output(val);
      } else if (typeof t === 'string') {
        if (t === 'bytes') {
          return this.deep_copy_bytes({
            t: t,
            val: val
          });
        } else {
          return this.deep_copy_simple({
            t: t,
            val: val
          });
        }
      } else if (typeof t !== 'object') {
        return this.output("ERROR");
      } else if (Array.isArray(t)) {
        if (t[0] != null) {
          return this.output("ERROR");
        } else {
          return this.deep_copy_pointer({
            t: t,
            val: val
          });
        }
      } else if (t.type === 'array') {
        return this.deep_copy_array({
          t: t,
          val: val
        });
      } else if (t.type === 'map') {
        return this.deep_copy_map({
          t: t,
          val: val
        });
      } else {
        return this.output("ERROR");
      }
    };

    GoEmitter.prototype.is_primitive_type_lax = function(t) {
      return t === 'int64' || t === 'long' || t === 'int' || t === 'float' || t === 'double' || t === 'string' || t === 'boolean' || t === 'bool' || t === 'uint' || t === 'unsigned' || t === 'uint64';
    };

    GoEmitter.prototype.deep_copy_bytes = function(_arg) {
      var t, type, val;
      t = _arg.t, val = _arg.val;
      type = this.emit_field_type(t).type;
      this.deep_copy_preamble({
        type: type
      });
      this.output("if x == nil {");
      this.tab();
      this.output("return nil");
      this.untab();
      this.output("}");
      this.output("return append([]byte{}, x...)");
      return this.deep_copy_postamble({
        val: val
      });
    };

    GoEmitter.prototype.deep_copy_simple = function(_arg) {
      var t, val;
      t = _arg.t, val = _arg.val;
      if (!this.is_primitive_type_lax(t)) {
        val += ".DeepCopy()";
      }
      return this.output(val);
    };

    GoEmitter.prototype.deep_copy_preamble = function(_arg) {
      var type;
      type = _arg.type;
      this.output("(func (x " + type + ") " + type + " {");
      return this.tab();
    };

    GoEmitter.prototype.deep_copy_postamble = function(_arg) {
      var val;
      val = _arg.val;
      this.untab();
      return this.output("})(" + val + ")");
    };

    GoEmitter.prototype.deep_copy_pointer = function(_arg) {
      var t, type, val;
      t = _arg.t, val = _arg.val;
      type = this.emit_field_type(t).type;
      this.deep_copy_preamble({
        type: type
      });
      this.output("if x == nil {");
      this.tab();
      this.output("return nil");
      this.untab();
      this.output("}");
      this.output("tmp := ", {
        frag: true
      });
      this.deep_copy({
        t: t[1],
        val: "(*x)",
        exported: true
      });
      this.output("return &tmp");
      return this.deep_copy_postamble({
        val: val
      });
    };

    GoEmitter.prototype.deep_copy_array = function(_arg) {
      var t, type, val;
      t = _arg.t, val = _arg.val;
      type = this.emit_field_type(t).type;
      this.deep_copy_preamble({
        type: type
      });
      this.output("if x == nil {");
      this.tab();
      this.output("return nil");
      this.untab();
      this.output("}");
      this.output("ret := make(" + type + ", len(x))");
      this.output("for i, v := range x {");
      this.tab();
      this.output("vCopy := ", {
        frag: true
      });
      this.deep_copy({
        t: t.items,
        val: "v",
        exported: true
      });
      this.output("ret[i] = vCopy");
      this.untab();
      this.output("}");
      this.output("return ret");
      return this.deep_copy_postamble({
        val: val
      });
    };

    GoEmitter.prototype.deep_copy_map = function(_arg) {
      var t, type, val;
      t = _arg.t, val = _arg.val;
      type = this.emit_field_type(t).type;
      this.deep_copy_preamble({
        type: type
      });
      this.output("if x == nil {");
      this.tab();
      this.output("return nil");
      this.untab();
      this.output("}");
      this.output("ret := make(" + type + ", len(x))");
      this.output("for k, v := range x {");
      this.tab();
      if (t.keys != null) {
        this.output("kCopy := ", {
          frag: true
        });
        this.deep_copy({
          t: t.keys,
          val: "k",
          exported: true
        });
      } else {
        this.output("kCopy := k");
      }
      this.output("vCopy := ", {
        frag: true
      });
      this.deep_copy({
        t: t.values,
        val: "v",
        exported: true
      });
      this.output("ret[kCopy] = vCopy");
      this.untab();
      this.output("}");
      this.output("return ret");
      return this.deep_copy_postamble({
        val: val
      });
    };

    GoEmitter.prototype.emit_deep_copy_field = function(_arg) {
      var exported, field, go_field_suffix, name, receiver, t;
      t = _arg.t, name = _arg.name, go_field_suffix = _arg.go_field_suffix, receiver = _arg.receiver, exported = _arg.exported;
      field = this.go_translate_identifier({
        name: name,
        go_field_suffix: go_field_suffix,
        exported: exported
      });
      this.output(field + ": ", {
        frag: true
      });
      this.deep_copy({
        t: t,
        val: "" + receiver + "." + field,
        exported: exported
      });
      return this.append_to_last(",");
    };

    GoEmitter.prototype.emit_record_deep_copy = function(_arg) {
      var f, go_field_suffix, obj, receiver, type, _i, _len, _ref;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      type = this.go_export_case(obj.name);
      receiver = "o";
      this.output("func (" + receiver + " " + type + ") DeepCopy() " + type + " {");
      this.tab();
      this.output("return " + type + "{");
      this.tab();
      _ref = obj.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        this.emit_deep_copy_field({
          t: f.type,
          name: f.name,
          go_field_suffix: go_field_suffix,
          receiver: receiver,
          exported: !(f.internal != null)
        });
      }
      this.untab();
      this.output("}");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.go_unsnake = function(_arg) {
      var i, is_private, n, part, parts, recase;
      n = _arg.n, is_private = _arg.is_private;
      parts = n.split(/_+/);
      recase = function(n, i) {
        if (is_private && i === 0) {
          return n.toLowerCase();
        } else {
          return n[0].toUpperCase() + n.slice(1).toLowerCase();
        }
      };
      return ((function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = parts.length; _i < _len; i = ++_i) {
          part = parts[i];
          _results.push(recase(part, i));
        }
        return _results;
      })()).join("");
    };

    GoEmitter.prototype.case_label_to_go = function(_arg) {
      var is_private, label, prefixed, tmp;
      label = _arg.label, prefixed = _arg.prefixed, is_private = _arg.is_private;
      tmp = label == null ? "Default" : typeof label === 'number' ? prefixed ? "Int" + label : label.toString() : label.toString();
      return this.go_unsnake({
        n: tmp,
        is_private: is_private
      });
    };

    GoEmitter.prototype.emit_variant_tag_getter = function(_arg) {
      var c, field, fname, go_field_suffix, obj, optional, ret_type, type, _i, _len, _ref, _ref1;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      _ref = this.emit_field_type(obj["switch"].type, {
        pointed: false
      }), type = _ref.type, optional = _ref.optional;
      ret_type = type;
      fname = this.go_translate_identifier({
        name: obj["switch"].name,
        exported: true
      });
      this.output("func (o *" + (this.go_export_case(obj.name)) + ") " + fname + "() (ret " + ret_type + ", err error) {");
      this.tab();
      this.output("switch (o." + (this.variant_field(obj["switch"].name)) + ") {");
      this.tab();
      _ref1 = obj.cases;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        c = _ref1[_i];
        if (!c.body) {
          continue;
        }
        field = this.variant_field(this.case_label_to_go({
          label: c.label.name,
          prefixed: true
        }));
        if (c.label.name != null) {
          this.output("case " + (this.variant_switch_value({
            c: c,
            obj: obj
          })) + ":");
        } else {
          this.output("default:");
        }
        this.tab();
        this.output("if o." + field + " == nil {");
        this.tab();
        this.output("err = errors.New(\"unexpected nil value for " + field + "\")");
        this.output("return ret, err");
        this.untab();
        this.output("}");
        this.untab();
      }
      this.untab();
      this.output("}");
      this.output("return o." + (this.variant_field(obj["switch"].name)) + ", nil");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_variant_case_getters = function(_arg) {
      var c, cases, def, go_field_suffix, obj, _i, _len, _ref;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      cases = [];
      def = null;
      _ref = obj.cases;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        if (c.label.def) {
          def = c;
        } else if (c.body != null) {
          cases.push(this.emit_variant_case_getter({
            obj: obj,
            c: c,
            go_field_suffix: go_field_suffix
          }));
        }
      }
      if (def && (def.body != null)) {
        return cases.push(this.emit_variant_case_getter({
          obj: obj,
          c: def,
          go_field_suffix: go_field_suffix,
          cases: cases,
          def: true
        }));
      }
    };

    GoEmitter.prototype.variant_suffix = function() {
      return "__";
    };

    GoEmitter.prototype.variant_field = function(name) {
      return this.go_translate_identifier({
        name: name,
        go_field_suffix: this.variant_suffix(),
        exported: true
      });
    };

    GoEmitter.prototype.variant_switch_value = function(_arg) {
      var c, obj, tag_val;
      obj = _arg.obj, c = _arg.c;
      tag_val = c.label.name;
      if (!this.is_primitive_switch_type(obj["switch"].type)) {
        tag_val = this.go_lint_capitalize(obj["switch"].type) + "_" + tag_val;
      }
      return tag_val;
    };

    GoEmitter.prototype.emit_variant_case_getter = function(_arg) {
      var c, cases, def, go_field_suffix, go_label, obj, optional, ret_type, tag_val, type, v, _ref;
      obj = _arg.obj, c = _arg.c, go_field_suffix = _arg.go_field_suffix, cases = _arg.cases, def = _arg.def;
      _ref = this.emit_field_type(c.body, {
        pointed: false
      }), type = _ref.type, optional = _ref.optional;
      ret_type = type;
      go_label = this.case_label_to_go({
        label: c.label.name,
        prefixed: true
      });
      tag_val = this.variant_switch_value({
        obj: obj,
        c: c
      });
      this.output("func (o " + (this.go_export_case(obj.name)) + ") " + go_label + "() (res " + ret_type + ") {");
      this.tab();
      if (def) {
        cases = (function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = cases.length; _i < _len; _i++) {
            v = cases[_i];
            _results.push("o." + (this.variant_field(obj["switch"].name)) + " == " + v);
          }
          return _results;
        }).call(this);
        this.output("if " + (cases.join(" || ")) + " {");
      } else {
        this.output("if o." + (this.variant_field(obj["switch"].name)) + " != " + tag_val + " {");
      }
      this.tab();
      this.output("panic(\"wrong case accessed\")");
      this.untab();
      this.output("}");
      this.output("if o." + (this.variant_field(go_label)) + " == nil {");
      this.tab();
      this.output("return");
      this.untab();
      this.output("}");
      this.output("return *o." + (this.variant_field(go_label)));
      this.untab();
      this.output("}");
      return tag_val;
    };

    GoEmitter.prototype.emit_variant_getters = function(_arg) {
      var go_field_suffix, obj;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      this.emit_variant_tag_getter({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
      return this.emit_variant_case_getters({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
    };

    GoEmitter.prototype.emit_variant_constructors = function(_arg) {
      var c, go_field_suffix, obj, _i, _len, _ref, _results;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      _ref = obj.cases;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(this.emit_variant_case_constructor({
          obj: obj,
          c: c,
          go_field_suffix: go_field_suffix
        }));
      }
      return _results;
    };

    GoEmitter.prototype.emit_variant_case_constructor = function(_arg) {
      var c, case_type, go_field_suffix, go_label_prefixed, go_label_unprefixed, klass, obj, tag_val, type;
      obj = _arg.obj, c = _arg.c, go_field_suffix = _arg.go_field_suffix;
      if (c.body != null) {
        type = this.emit_field_type(c.body, {
          pointed: false
        }).type;
        case_type = type;
      }
      klass = this.go_export_case(obj.name);
      go_label_prefixed = this.case_label_to_go({
        label: c.label.name,
        prefixed: true
      });
      go_label_unprefixed = this.case_label_to_go({
        label: c.label.name,
        prefixed: false
      });
      if (!c.label.def) {
        tag_val = c.label.name;
        if (!this.is_primitive_switch_type(obj["switch"].type)) {
          tag_val = this.go_lint_capitalize(obj["switch"].type) + "_" + tag_val;
        }
        if (c.body != null) {
          this.output("func New" + klass + "With" + go_label_unprefixed + "(v " + case_type + ") " + klass + " {");
        } else {
          this.output("func New" + klass + "With" + go_label_unprefixed + "() " + klass + " {");
        }
      } else if (c.body != null) {
        this.output("func New" + klass + "Default(" + obj["switch"].name + " " + obj["switch"].type + ", v " + case_type + ") " + klass + " {");
        tag_val = obj["switch"].name;
      } else {
        this.output("func New" + klass + "Default(" + obj["switch"].name + " " + obj["switch"].type + ") " + klass + " {");
        tag_val = obj["switch"].name;
      }
      this.tab();
      this.output("return " + klass + "{");
      this.tab();
      this.output("" + (this.variant_field(obj["switch"].name)) + " : " + tag_val + ",");
      if (c.body != null) {
        this.output("" + (this.variant_field(go_label_prefixed)) + " : &v,");
      }
      this.untab();
      this.output("}");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_variant = function(_arg) {
      var go_field_suffix, obj;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      this.emit_variant_object({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
      this.emit_variant_getters({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
      this.emit_variant_constructors({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
      return this.emit_variant_deep_copy({
        obj: obj,
        go_field_suffix: go_field_suffix
      });
    };

    GoEmitter.prototype.emit_variant_object = function(_arg) {
      var body, go_field_suffix, label, name, obj, _i, _len, _ref, _ref1;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      this.output("type " + (this.go_export_case(obj.name)) + " struct {");
      this.tab();
      go_field_suffix = this.variant_suffix();
      this.emit_field({
        name: obj["switch"].name,
        type: obj["switch"].type,
        go_field_suffix: go_field_suffix,
        exported: true
      });
      _ref = obj.cases;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], label = _ref1.label, body = _ref1.body;
        if (!(body != null)) {
          continue;
        }
        name = this.case_label_to_go({
          label: label.name,
          prefixed: true,
          is_private: true
        });
        this.emit_field({
          name: name,
          type: body,
          exported: true,
          pointed: true,
          go_field_suffix: go_field_suffix
        });
      }
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_variant_deep_copy = function(_arg) {
      var body, go_field_suffix, label, name, obj, receiver, type, _i, _len, _ref, _ref1;
      obj = _arg.obj, go_field_suffix = _arg.go_field_suffix;
      go_field_suffix = this.variant_suffix();
      type = this.go_export_case(obj.name);
      receiver = "o";
      this.output("func (" + receiver + " " + type + ") DeepCopy() " + type + " {");
      this.tab();
      this.output("return " + type + " {");
      this.tab();
      this.emit_deep_copy_field({
        t: obj["switch"].type,
        name: obj["switch"].name,
        go_field_suffix: go_field_suffix,
        receiver: receiver,
        exported: true
      });
      _ref = obj.cases;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], label = _ref1.label, body = _ref1.body;
        if (!(body != null)) {
          continue;
        }
        name = this.case_label_to_go({
          label: label.name,
          prefixed: true,
          is_private: true
        });
        this.emit_deep_copy_field({
          t: [null, body],
          name: name,
          go_field_suffix: go_field_suffix,
          receiver: receiver,
          exported: true
        });
      }
      this.untab();
      this.output("}");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_fixed_deep_copy = function(_arg) {
      var t, type;
      t = _arg.t;
      type = t.name;
      this.output("func (o " + type + ") DeepCopy() " + type + " {");
      this.tab();
      this.output("var ret " + type);
      this.output("copy(ret[:], o[:])");
      this.output("return ret");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_fixed = function(t) {
      this.output("type " + t.name + " [" + t.size + "]byte");
      return this.emit_fixed_deep_copy({
        t: t
      });
    };

    GoEmitter.prototype.emit_types = function(_arg) {
      var go_field_suffix, type, types, _i, _len, _results;
      types = _arg.types, go_field_suffix = _arg.go_field_suffix;
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        _results.push(this.emit_type({
          type: type,
          go_field_suffix: go_field_suffix
        }));
      }
      return _results;
    };

    GoEmitter.prototype.count_variants = function(_arg) {
      var ret, type, types, _i, _len;
      types = _arg.types;
      ret = 0;
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (type.type === "variant") {
          ret++;
        }
      }
      return ret;
    };

    GoEmitter.prototype.count_enums_with_string = function(_arg) {
      var ret, type, types, _i, _len;
      types = _arg.types;
      ret = 0;
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        if (type.type === "enum" && type.go !== "nostring") {
          ret++;
        }
      }
      return ret;
    };

    GoEmitter.prototype.emit_type = function(_arg) {
      var go_field_suffix, nostring, type;
      type = _arg.type, go_field_suffix = _arg.go_field_suffix;
      this.output_doc(type.doc);
      switch (type.type) {
        case "record":
          if (type.typedef) {
            return this.emit_typedef(type);
          } else {
            return this.emit_record(type, {
              go_field_suffix: go_field_suffix
            });
          }
          break;
        case "fixed":
          return this.emit_fixed(type);
        case "enum":
          nostring = type.go === "nostring";
          return this.emit_enum(type, nostring);
        case "variant":
          return this.emit_variant({
            obj: type,
            go_field_suffix: go_field_suffix
          });
      }
    };

    GoEmitter.prototype.emit_enum = function(t, nostring) {
      var e_name, e_num, i, name, s, _, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      name = t.name;
      this.output("type " + name + " int");
      this.output("const (");
      this.tab();
      _ref = t.symbols;
      for (_ = _i = 0, _len = _ref.length; _i < _len; _ = ++_i) {
        s = _ref[_];
        _ref1 = s.split("_"), e_name = 2 <= _ref1.length ? __slice.call(_ref1, 0, _j = _ref1.length - 1) : (_j = 0, []), e_num = _ref1[_j++];
        e_name = e_name.join("_");
        this.output("" + name + "_" + e_name + " " + name + " = " + e_num);
      }
      this.untab();
      this.output(")");
      this.output("func (o " + name + ") DeepCopy() " + name + " { return o }");
      this.output("var " + name + "Map = map[string]" + name + "{");
      this.tab();
      _ref2 = t.symbols;
      for (i = _k = 0, _len1 = _ref2.length; _k < _len1; i = ++_k) {
        s = _ref2[i];
        _ref3 = s.split("_"), e_name = 2 <= _ref3.length ? __slice.call(_ref3, 0, _l = _ref3.length - 1) : (_l = 0, []), e_num = _ref3[_l++];
        e_name = e_name.join("_");
        this.output("\"" + e_name + "\": " + e_num + ",");
      }
      this.untab();
      this.output("}");
      this.output("var " + name + "RevMap = map[" + name + "]string{");
      this.tab();
      _ref4 = t.symbols;
      for (i = _m = 0, _len2 = _ref4.length; _m < _len2; i = ++_m) {
        s = _ref4[i];
        _ref5 = s.split("_"), e_name = 2 <= _ref5.length ? __slice.call(_ref5, 0, _n = _ref5.length - 1) : (_n = 0, []), e_num = _ref5[_n++];
        e_name = e_name.join("_");
        this.output("" + e_num + ": \"" + e_name + "\",");
      }
      this.untab();
      this.output("}");
      if (!nostring) {
        this.output("func (e " + name + ") String() string {");
        this.tab();
        this.output("if v, ok := " + name + "RevMap[e]; ok {");
        this.tab();
        this.output("return v");
        this.untab();
        this.output("}");
        this.output("return fmt.Sprintf(\"%v\", int(e))");
        this.untab();
        return this.output("}");
      }
    };

    GoEmitter.prototype.emit_wrapper_objects = function(_arg) {
      var k, messages, v, _results;
      messages = _arg.messages;
      _results = [];
      for (k in messages) {
        v = messages[k];
        _results.push(this.emit_wrapper_object({
          name: k,
          details: v
        }));
      }
      return _results;
    };

    GoEmitter.prototype.emit_wrapper_object = function(_arg) {
      var args, details, klass_name, name, obj;
      name = _arg.name, details = _arg.details;
      args = details.request;
      klass_name = this.go_export_case(name) + "Arg";
      obj = {
        name: klass_name,
        fields: args
      };
      this.emit_record(obj, {
        no_deep_copy: true
      });
      return details.request = {
        type: klass_name,
        name: "__arg",
        wrapper: true,
        nargs: args.length,
        single: args.length === 1 ? args[0] : null
      };
    };

    GoEmitter.prototype.emit_interface = function(_arg) {
      var doc, messages, protocol;
      protocol = _arg.protocol, messages = _arg.messages, doc = _arg.doc;
      this.emit_wrapper_objects({
        messages: messages
      });
      this.emit_interface_server({
        protocol: protocol,
        messages: messages,
        doc: doc
      });
      return this.emit_interface_client({
        protocol: protocol,
        messages: messages
      });
    };

    GoEmitter.prototype.emit_interface_client = function(_arg) {
      var k, messages, p, protocol, v, _results;
      protocol = _arg.protocol, messages = _arg.messages;
      p = this.go_export_case(protocol);
      this.output("type " + p + "Client struct {");
      this.tab();
      this.output("Cli rpc.GenericClient");
      this.untab();
      this.output("}");
      _results = [];
      for (k in messages) {
        v = messages[k];
        _results.push(this.emit_message_client({
          protocol: protocol,
          name: k,
          details: v,
          async: false
        }));
      }
      return _results;
    };

    GoEmitter.prototype.emit_package = function(_arg) {
      var compression_type, namespace;
      namespace = _arg.namespace, compression_type = _arg.compression_type;
      if (compression_type != null) {
        this._default_compression_type = compression_type;
      }
      this.output("package " + (this.go_package(namespace)));
      this.output("");
      return this._pkg = namespace;
    };

    GoEmitter.prototype.emit_imports = function(_arg, outfile, _arg1) {
      var import_as, imports, line, messages, path, prefix, relative_dir, relative_file, types, types_only, _i, _len, _ref;
      imports = _arg.imports, messages = _arg.messages, types = _arg.types;
      types_only = _arg1.types_only;
      this.output("import (");
      this.tab();
      if (!types_only) {
        this.output('"github.com/keybase/go-framed-msgpack-rpc/rpc"');
        if (Object.keys(messages).length > 0) {
          this.output('context "golang.org/x/net/context"');
        }
      }
      prefix = process.env.GOPATH + '/src/';
      relative_file = path_lib.resolve(outfile).replace(prefix, "");
      relative_dir = path_lib.dirname(relative_file);
      for (_i = 0, _len = imports.length; _i < _len; _i++) {
        _ref = imports[_i], import_as = _ref.import_as, path = _ref.path;
        if (!(path.indexOf('/') >= 0)) {
          continue;
        }
        if (path.match(/(\.\/|\.\.\/)/)) {
          path = path_lib.normalize(relative_dir + "/" + path);
        }
        line = "";
        if (import_as != null) {
          line = import_as + " ";
        }
        line += '"' + path + '"';
        this.output(line);
      }
      if (this.count_variants({
        types: types
      }) > 0) {
        this.output('"errors"');
      }
      if (this.count_enums_with_string({
        types: types
      }) > 0) {
        this.output('"fmt"');
      }
      if (Object.keys(messages).length > 0) {
        this.output('"time"');
      }
      this.untab();
      this.output(")");
      return this.output("");
    };

    GoEmitter.prototype.emit_interface_server = function(_arg) {
      var doc, k, messages, p, protocol, v;
      protocol = _arg.protocol, messages = _arg.messages, doc = _arg.doc;
      p = this.go_export_case(protocol);
      this.output_doc(doc);
      this.output("type " + p + "Interface interface {");
      this.tab();
      for (k in messages) {
        v = messages[k];
        this.emit_message_server({
          name: k,
          details: v
        });
      }
      this.untab();
      this.output("}");
      return this.emit_protocol_server({
        protocol: protocol,
        messages: messages
      });
    };

    GoEmitter.prototype.emit_server_hook = function(_arg) {
      var arg, details, name, res, resvar;
      name = _arg.name, details = _arg.details;
      arg = details.request;
      res = details.response;
      resvar = res != null ? "ret, " : "";
      this.output("\"" + name + "\": {");
      this.tab();
      this.emit_server_hook_make_arg({
        name: name,
        details: details
      });
      this.emit_server_hook_make_handler({
        name: name,
        details: details
      });
      this.untab();
      return this.output("},");
    };

    GoEmitter.prototype.emit_server_hook_make_arg = function(_arg) {
      var arg, details, name;
      name = _arg.name, details = _arg.details;
      arg = details.request;
      this.output("MakeArg: func() interface{} {");
      this.tab();
      this.output("var ret [1]" + (this.go_primitive_type(arg.type)));
      this.output("return &ret");
      this.untab();
      return this.output("},");
    };

    GoEmitter.prototype.emit_server_hook_make_handler = function(_arg) {
      var access, arg, details, farg, name, pt, res, resvar;
      name = _arg.name, details = _arg.details;
      arg = details.request;
      res = details.response;
      resvar = res != null ? "ret, " : "";
      pt = this.go_primitive_type(arg.type);
      this.output("Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {");
      this.tab();
      if (arg.nargs > 0) {
        this.output("typedArgs, ok := args.(*[1]" + pt + ")");
        this.output("if !ok {");
        this.tab();
        this.output("err = rpc.NewTypeError((*[1]" + pt + ")(nil), args)");
        this.output("return");
        this.untab();
        this.output("}");
      }
      farg = arg.nargs === 0 ? '' : (access = arg.nargs === 1 ? "." + (this.go_export_case(arg.single.name)) : '', "typedArgs[0]" + access);
      this.output("" + resvar + "err = i." + (this.go_export_case(name)) + "(ctx, " + farg + ")");
      this.output("return");
      this.untab();
      return this.output("},");
    };

    GoEmitter.prototype.emit_protocol_server = function(_arg) {
      var k, messages, p, protocol, v;
      protocol = _arg.protocol, messages = _arg.messages;
      p = this.go_export_case(protocol);
      this.output("func " + p + "Protocol(i " + p + "Interface) rpc.Protocol {");
      this.tab();
      this.output("return rpc.Protocol {");
      this.tab();
      this.output("Name: \"" + this._pkg + "." + protocol + "\",");
      this.output("Methods: map[string]rpc.ServeHandlerDescription{");
      this.tab();
      for (k in messages) {
        v = messages[k];
        this.emit_server_hook({
          name: k,
          details: v
        });
      }
      this.untab();
      this.output("},");
      this.untab();
      this.output("}");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_message_server = function(_arg) {
      var arg, args, details, name, res, res_types;
      name = _arg.name, details = _arg.details;
      arg = details.request;
      res = details.response;
      args = arg.nargs ? "" + (this.emit_field_type((arg.single || arg).type)).type : "";
      res_types = [];
      if (res != null) {
        res_types.push(this.go_lint_capitalize(this.emit_field_type(res).type));
      }
      res_types.push("error");
      this.output_doc(details.doc);
      return this.output("" + (this.go_export_case(name)) + "(context.Context, " + args + ") (" + (res_types.join(",")) + ")");
    };

    GoEmitter.prototype.emit_message_client = function(_arg) {
      var arg, async, call_method, ctype, ctype_in, details, n, name, oarg, out_list, outs, ow, p, params, parg, protocol, res, res_in, timeout;
      protocol = _arg.protocol, name = _arg.name, details = _arg.details, async = _arg.async;
      p = this.go_export_case(protocol);
      arg = details.request;
      res = details.response;
      out_list = [];
      if (res != null) {
        out_list.push("res " + (this.go_lint_capitalize(this.emit_field_type(res).type)));
        res_in = "&res";
      } else {
        res_in = "nil";
      }
      out_list.push("err error");
      outs = out_list.join(",");
      params = arg.nargs === 0 ? "" : (parg = arg.single || arg, "" + parg.name + " " + (this.emit_field_type(parg.type)).type);
      this.output_doc(details.doc);
      this.output("func (c " + p + "Client) " + (this.go_export_case(name)) + "(ctx context.Context, " + params + ") (" + outs + ") {");
      this.tab();
      if (arg.nargs === 1) {
        n = arg.single.name;
        this.output("" + arg.name + " := " + arg.type + "{ " + (this.go_export_case(n)) + " : " + n + " }");
      }
      oarg = "[]interface{}{";
      oarg += arg.nargs === 0 ? "" + arg.type + "{}" : arg.name;
      oarg += "}";
      ow = is_one_way(details);
      res = ow ? "" : ", " + res_in;
      ctype = "";
      call_method = "Call";
      if (!ow) {
        ctype_in = details.compression_type != null ? details.compression_type : this._default_compression_type;
        if (ctype_in !== "none") {
          call_method = "CallCompressed";
          ctype = ", " + (this.go_compression_type(ctype_in));
        }
      }
      timeout = ", " + (details.timeout_msec || 0) + " * time.Millisecond";
      this.output("err = c.Cli." + (ow ? "Notify" : call_method) + "(ctx, \"" + this._pkg + "." + protocol + "." + name + "\", " + oarg + res + ctype + timeout + ")");
      this.output("return");
      this.untab();
      return this.output("}");
    };

    GoEmitter.prototype.emit_preface = function(infiles, json, _arg) {
      var infile, types_only, _i, _len;
      types_only = (_arg != null ? _arg : {}).types_only;
      this.output("// Auto-generated to Go " + (types_only ? 'types' : 'types and interfaces') + " using " + pkg.name + " v" + pkg.version + " (" + pkg.homepage + ")");
      if (infiles.length === 1) {
        this.output("//   Input file: " + (path_lib.relative(process.cwd(), infiles[0])));
      } else {
        this.output("//   Input files:");
        for (_i = 0, _len = infiles.length; _i < _len; _i++) {
          infile = infiles[_i];
          this.output("//   - " + (path_lib.relative(process.cwd(), infiles)));
        }
      }
      this.output("");
      return this.emit_package(json);
    };

    return GoEmitter;

  })(BaseEmitter);

}).call(this);
