// Generated by IcedCoffeeScript 108.0.13
(function() {
  var BaseEmitter, PythonEmitter, isEqual, is_primitive, path_lib, pkg, snakeCase, uniqWith, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  path_lib = require('path');

  BaseEmitter = require('./base_emitter').BaseEmitter;

  pkg = require('../package.json');

  _ref = require('lodash'), uniqWith = _ref.uniqWith, isEqual = _ref.isEqual, snakeCase = _ref.snakeCase;

  is_primitive = require('./utils').is_primitive;

  exports.PythonEmitter = PythonEmitter = (function(_super) {
    __extends(PythonEmitter, _super);

    function PythonEmitter() {
      PythonEmitter.__super__.constructor.apply(this, arguments);
      this._tab_char = " ".repeat(4);
      this._keywords = new Set(['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield', 'self', 'config']);
    }

    PythonEmitter.prototype.format_name = function(name) {
      var formatted_name;
      formatted_name = snakeCase(name);
      if (this._keywords.has(formatted_name)) {
        formatted_name += '_';
      }
      return formatted_name;
    };

    PythonEmitter.prototype.output_doc = function(d) {
      var line, _i, _len, _ref1;
      if (d != null) {
        this.output('"""');
        _ref1 = d.split(/\n/);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          line = _ref1[_i];
          this.output(line.replace(/^\s*/, ''));
        }
        return this.output('"""');
      }
    };

    PythonEmitter.prototype.emit_type = function(type) {
      switch (type.type) {
        case "record":
          if (type.typedef) {
            return this.emit_typedef(type);
          } else {
            return this.emit_record(type);
          }
          break;
        case "fixed":
          return this.emit_fixed(type);
        case "enum":
          return this.emit_enum(type);
        case "variant":
          return this.emit_variant(type);
      }
    };

    PythonEmitter.prototype.emit_primitive_type = function(m) {
      var map;
      map = {
        string: "str",
        bytes: "str",
        boolean: "bool",
        double: "float",
        long: "int",
        int64: "int",
        uint: "int",
        uint64: "int"
      };
      return map[m] || m;
    };

    PythonEmitter.prototype.emit_field_type = function(t, _arg) {
      var optional, optionalkey, pointed, type, _ref1;
      _ref1 = _arg != null ? _arg : {}, pointed = _ref1.pointed, optionalkey = _ref1.optionalkey;
      optional = optionalkey;
      type = (function() {
        if (typeof t === 'string') {
          return this.emit_primitive_type(t);
        } else if (typeof t === 'object') {
          if (Array.isArray(t)) {
            if (t[0] == null) {
              optional = true;
              return this.emit_field_type(t[1]).type;
            } else {
              throw new Error("Unrecognized type");
            }
          } else if (t.type === "array") {
            optional = true;
            return "List[" + (this.emit_field_type(t.items).type) + "]";
          } else if (t.type === "map") {
            return this.make_map_type(t);
          } else {
            throw new Error("Unrecognized type");
          }
        } else {
          throw new Error("Unrecognized type");
        }
      }).call(this);
      return {
        type: type,
        optional: optional
      };
    };

    PythonEmitter.prototype.make_map_type = function(t) {
      var optional, type, _ref1;
      _ref1 = this.emit_field_type(t.values), optional = _ref1.optional, type = _ref1.type;
      if (optional) {
        type = "Optional[" + type + "]";
      }
      return "Dict[str, " + type + "]";
    };

    PythonEmitter.prototype.emit_preface = function(infiles, _arg) {
      var infile, namespace, _i, _len;
      namespace = _arg.namespace;
      this.output('"""' + namespace);
      this.output("");
      this.output("Auto-generated to Python types by " + pkg.name + " v" + pkg.version + " (" + pkg.homepage + ")");
      this.output("Input files:");
      for (_i = 0, _len = infiles.length; _i < _len; _i++) {
        infile = infiles[_i];
        this.output(" - " + (path_lib.relative(process.cwd(), infile)));
      }
      this.output('"""');
      return this.output("");
    };

    PythonEmitter.prototype.emit_imports = function(_arg, outfile) {
      var import_as, imports, path, relative_dir, _i, _len, _ref1;
      imports = _arg.imports;
      this.output("from dataclasses import dataclass, field");
      this.output("from enum import Enum");
      this.output("from typing import Dict, List, Optional, Union");
      this.output("from typing_extensions import Literal");
      this.output("");
      this.output("from dataclasses_json import config, DataClassJsonMixin");
      this.output("");
      imports = uniqWith(imports, isEqual);
      relative_dir = path_lib.dirname(outfile);
      for (_i = 0, _len = imports.length; _i < _len; _i++) {
        _ref1 = imports[_i], import_as = _ref1.import_as, path = _ref1.path;
        if (import_as == null) {
          continue;
        }
        if (path.match(/(\.\/|\.\.\/)/)) {
          path = path_lib.normalize(relative_dir + "/" + path);
        }
        path = path.replace(/\//g, '.');
        if (path[0] === '.') {
          path = path.slice(1);
        }
        this.output("import " + path + " as " + import_as);
      }
      return this.output("");
    };

    PythonEmitter.prototype.emit_typedef = function(type) {
      return this.output("" + type.name + " = " + (this.emit_field_type(type.typedef).type));
    };

    PythonEmitter.prototype.emit_fixed = function(type) {
      return this.output("" + type.name + " = Optional[str]");
    };

    PythonEmitter.prototype.emit_field = function(_arg) {
      var field_name, jsonkey, name, optional, optionalkey, type, _ref1;
      name = _arg.name, type = _arg.type, jsonkey = _arg.jsonkey, optionalkey = _arg.optionalkey;
      _ref1 = this.emit_field_type(type, {
        optionalkey: optionalkey
      }), type = _ref1.type, optional = _ref1.optional;
      field_name = this.format_name(name);
      type = optional ? "Optional[" + type + "]" : type;
      return this.output("" + field_name + ": " + type + " = field(" + (optional ? 'default=None, ' : '') + "metadata=config(field_name='" + (jsonkey || name) + "'))");
    };

    PythonEmitter.prototype.is_optional = function(field) {
      if (Array.isArray(field.type) && (field.type[0] == null)) {
        return true;
      }
      if (typeof field.type === 'object' && field.type.type === 'array') {
        return true;
      }
      return Boolean(field.optional);
    };

    PythonEmitter.prototype.emit_record = function(record) {
      var f, fields, _i, _len;
      this.output("@dataclass");
      this.output("class " + record.name + "(DataClassJsonMixin):");
      this.tab();
      fields = record.fields.sort((function(_this) {
        return function(a, b) {
          if (_this.is_optional(a) && !_this.is_optional(b)) {
            return 1;
          }
          if (!_this.is_optional(a) && _this.is_optional(b)) {
            return -1;
          }
          return 0;
        };
      })(this));
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        f = fields[_i];
        this.emit_field({
          name: f.name,
          type: f.type,
          jsonkey: f.jsonkey,
          optionalkey: f.optional
        });
      }
      if (fields.length === 0) {
        this.output("pass");
      }
      this.untab();
      return this.output("");
    };

    PythonEmitter.prototype.emit_enum = function(type) {
      var e_name, e_num, s, _, _i, _j, _k, _l, _len, _len1, _ref1, _ref2, _ref3, _ref4;
      this.output("class " + type.name + "(Enum):");
      this.tab();
      this.output_doc(type.doc);
      _ref1 = type.symbols;
      for (_ = _i = 0, _len = _ref1.length; _i < _len; _ = ++_i) {
        s = _ref1[_];
        _ref2 = s.split("_"), e_name = 2 <= _ref2.length ? __slice.call(_ref2, 0, _j = _ref2.length - 1) : (_j = 0, []), e_num = _ref2[_j++];
        e_name = e_name.join("_");
        this.output("" + e_name + " = " + e_num);
      }
      this.untab();
      this.output("");
      this.output("class " + type.name + "Strings(Enum):");
      this.tab();
      _ref3 = type.symbols;
      for (_ = _k = 0, _len1 = _ref3.length; _k < _len1; _ = ++_k) {
        s = _ref3[_];
        _ref4 = s.split("_"), e_name = 2 <= _ref4.length ? __slice.call(_ref4, 0, _l = _ref4.length - 1) : (_l = 0, []), e_num = _ref4[_l++];
        e_name = e_name.join("_");
        this.output("" + e_name + " = '" + (e_name.toLowerCase()) + "'");
      }
      this.untab();
      return this.output("\n");
    };

    PythonEmitter.prototype.emit_variant = function(type) {
      var cases, is_switch_primitive;
      is_switch_primitive = is_primitive(type["switch"].type);
      cases = type.cases.map((function(_this) {
        return function(type_case) {
          var bodyType;
          if (type_case.label.def) {
            return null;
          }
          bodyType = (function() {
            switch (false) {
              case type_case.body !== null:
                return 'None';
              case typeof type_case.body !== 'string':
                return "Optional[" + (this.emit_primitive_type(type_case.body)) + "]";
              case type_case.body.type !== 'array':
                return "Optional[List[" + (this.emit_primitive_type(type_case.body.items)) + "]]";
              default:
                throw new Error("Unrecognized type");
            }
          }).call(_this);
          _this.output("@dataclass");
          _this.output("class " + type.name + "__" + type_case.label.name + "(DataClassJsonMixin):");
          _this.tab();
          _this.output("" + type["switch"].name + ": Literal[" + (is_switch_primitive ? '' : type["switch"].type + 'Strings.') + type_case.label.name + "]");
          _this.output("" + type_case.label.name + ": " + bodyType);
          _this.untab();
          _this.output("");
          return "" + type.name + "__" + type_case.label.name;
        };
      })(this)).filter(Boolean);
      this.output("" + type.name + " = Union[" + (cases.join(", ")) + "]");
      return this.output("");
    };

    return PythonEmitter;

  })(BaseEmitter);

}).call(this);
