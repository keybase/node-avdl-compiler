// Generated by IcedCoffeeScript 108.0.11
(function() {
  var BaseEmitter, TypescriptEmitter, camelCase, isEqual, is_primitive, path_lib, pkg, uniqBy, uniqWith, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  path_lib = require('path');

  BaseEmitter = require('./base_emitter').BaseEmitter;

  pkg = require('../package.json');

  _ref = require('lodash'), camelCase = _ref.camelCase, uniqBy = _ref.uniqBy, uniqWith = _ref.uniqWith, isEqual = _ref.isEqual;

  is_primitive = require('./utils').is_primitive;

  exports.TypescriptEmitter = TypescriptEmitter = (function(_super) {
    __extends(TypescriptEmitter, _super);

    function TypescriptEmitter() {
      TypescriptEmitter.__super__.constructor.apply(this, arguments);
      this._tab_char = " ".repeat(2);
    }

    TypescriptEmitter.prototype.emit_preface = function(infiles, _arg) {
      var doc, infile, line, namespace, _i, _j, _len, _len1, _ref1;
      namespace = _arg.namespace, doc = _arg.doc;
      this.output("/*");
      this.output(" * " + namespace);
      if (doc != null) {
        _ref1 = doc.split(/\n/);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          line = _ref1[_i];
          this.output(" * " + line.replace(/^\s$/, ''));
        }
      }
      this.output(" *");
      this.output(" * Auto-generated to TypeScript types by " + pkg.name + " v" + pkg.version + " (" + pkg.homepage + ")");
      this.output(" * Input files:");
      for (_j = 0, _len1 = infiles.length; _j < _len1; _j++) {
        infile = infiles[_j];
        this.output(" * - " + (path_lib.relative(process.cwd(), infile)));
      }
      this.output(" */");
      return this.output("");
    };

    TypescriptEmitter.prototype.output_doc = function(doc) {
      var line, _i, _len, _ref1;
      if (doc != null) {
        this.output("/**");
        _ref1 = doc.split(/\n/);
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          line = _ref1[_i];
          this.output(" * " + line.replace(/^\s$/, ''));
        }
        return this.output(" */");
      }
    };

    TypescriptEmitter.prototype.convert_primitive_type = function(type) {
      var map;
      map = {
        bool: "boolean",
        bytes: "Buffer",
        long: "number",
        float: "number",
        double: "number",
        uint: "number",
        int: "number",
        uint64: "number",
        int64: "number"
      };
      return map[type] || type;
    };

    TypescriptEmitter.prototype.make_map_type = function(type) {
      return "{[key: string]: " + (this.emit_field_type(type.values).type) + "}";
    };

    TypescriptEmitter.prototype.emit_field_type = function(t, _arg) {
      var optional, optionalkey, type;
      optionalkey = (_arg != null ? _arg : {}).optionalkey;
      optional = optionalkey != null;
      type = (function() {
        if (typeof t === 'string') {
          return this.convert_primitive_type(t);
        } else if (typeof t === 'object') {
          if (Array.isArray(t)) {
            if (t[0] == null) {
              optional = true;
              return this.emit_field_type(t[1]).type;
            } else {
              throw new Error("Unrecognized type");
            }
          } else if (t.type === "array") {
            return this.emit_field_type(t.items).type + "[] | null";
          } else if (t.type === "map") {
            return this.make_map_type(t);
          } else {
            throw new Error("Unrecognized type");
          }
        } else {
          throw new Error("Unrecognized type");
        }
      }).call(this);
      return {
        type: type,
        optional: optional
      };
    };

    TypescriptEmitter.prototype.emit_typedef = function(type) {
      this.output("export type " + type.name + " = " + (this.emit_field_type(type.typedef).type));
      return this.output("");
    };

    TypescriptEmitter.prototype.emit_imports = function(_arg) {
      var import_as, imports, imports_to_emit, path, _i, _len, _ref1;
      imports = _arg.imports;
      imports = uniqWith(imports, isEqual);
      imports_to_emit = imports.filter(function(imp) {
        return imp.path.indexOf('/') >= 0;
      });
      for (_i = 0, _len = imports_to_emit.length; _i < _len; _i++) {
        _ref1 = imports_to_emit[_i], import_as = _ref1.import_as, path = _ref1.path;
        if (import_as) {
          this.output("import * as " + import_as + " from '" + path + "'");
        }
      }
      if (imports_to_emit.length > 0) {
        return this.output("");
      }
    };

    TypescriptEmitter.prototype.emit_fixed = function(type) {
      return this.output("export type " + type.name + " = string | null");
    };

    TypescriptEmitter.prototype.emit_field = function(_arg) {
      var fieldName, jsonkey, name, optional, optionalkey, type, _ref1;
      name = _arg.name, type = _arg.type, jsonkey = _arg.jsonkey, optionalkey = _arg.optionalkey;
      _ref1 = this.emit_field_type(type, {
        optionalkey: optionalkey
      }), type = _ref1.type, optional = _ref1.optional;
      fieldName = camelCase(jsonkey || name);
      return this.output("" + fieldName + (optional ? '?' : '') + ": " + type);
    };

    TypescriptEmitter.prototype.emit_record = function(record) {
      var f, fields, _i, _len;
      this.output("export type " + record.name + " = {");
      this.tab();
      fields = uniqWith(record.fields, function(a, b) {
        return camelCase(a.jsonkey || a.name) === camelCase(b.jsonkey || b.name);
      });
      for (_i = 0, _len = fields.length; _i < _len; _i++) {
        f = fields[_i];
        this.emit_field({
          name: f.name,
          type: f.type,
          jsonkey: f.jsonkey,
          optionalkey: f.optional
        });
      }
      this.untab();
      return this.output("}");
    };

    TypescriptEmitter.prototype.emit_enum = function(type) {
      var e_name, e_num, s, _, _i, _j, _len, _ref1, _ref2;
      this.output("export enum " + type.name + " {");
      this.tab();
      _ref1 = type.symbols;
      for (_ = _i = 0, _len = _ref1.length; _i < _len; _ = ++_i) {
        s = _ref1[_];
        _ref2 = s.split("_"), e_name = 2 <= _ref2.length ? __slice.call(_ref2, 0, _j = _ref2.length - 1) : (_j = 0, []), e_num = _ref2[_j++];
        e_name = e_name.join("_");
        this.output("" + e_name + " = '" + (e_name.toLowerCase()) + "',");
      }
      this.untab();
      return this.output("}");
    };

    TypescriptEmitter.prototype.emit_variant = function(type) {
      var case_strings, handled_cases, is_switch_primitive;
      is_switch_primitive = is_primitive(type["switch"].type);
      handled_cases = [];
      case_strings = type.cases.map((function(_this) {
        return function(type_case) {
          var bodyStr, bodyType;
          if (type_case.label.def) {
            return null;
          }
          bodyType = (function() {
            switch (false) {
              case type_case.body !== null:
                return 'null';
              case typeof type_case.body !== 'string':
                return this.convert_primitive_type(type_case.body);
              case type_case.body.type !== 'array':
                return this.convert_primitive_type(type_case.body.items) + '[]';
              default:
                throw new Error("Unrecognized type");
            }
          }).call(_this);
          handled_cases.push("" + type["switch"].type + "." + type_case.label.name);
          bodyStr = type_case.body ? ", '" + type_case.label.name + "': " + bodyType : '';
          return "{ " + type["switch"].name + ": " + (is_switch_primitive ? '' : type["switch"].type + '.') + type_case.label.name + bodyStr + " }";
        };
      })(this)).filter(Boolean);
      case_strings.push("{ " + type["switch"].name + ": Exclude<" + type["switch"].type + ", " + (handled_cases.join(' | ')) + "> }");
      this.output("export type " + type.name + " = " + (case_strings.join(" | ")));
      return this.output("");
    };

    return TypescriptEmitter;

  })(BaseEmitter);

}).call(this);
