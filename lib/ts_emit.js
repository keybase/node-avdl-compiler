// Generated by IcedCoffeeScript 108.0.11
(function() {
  var TypescriptEmitter, path_lib, pkg,
    __slice = [].slice;

  path_lib = require('path');

  pkg = require('../package.json');

  exports.TypescriptEmitter = TypescriptEmitter = (function() {
    function TypescriptEmitter() {
      this._code = [];
      this._tabs = 0;
    }

    TypescriptEmitter.prototype.tab = function() {
      return this._tabs++;
    };

    TypescriptEmitter.prototype.untab = function() {
      return this._tabs--;
    };

    TypescriptEmitter.prototype.tabs = function() {
      var i;
      return ((function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 0, _ref = this._tabs; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
          _results.push("  ");
        }
        return _results;
      }).call(this)).join("");
    };

    TypescriptEmitter.prototype.output = function(l, _arg) {
      var frag;
      frag = (_arg != null ? _arg : {}).frag;
      if (this._last_frag) {
        this._code[this._code.length - 1] += l;
        this._last_frag = false;
      } else {
        this._code.push(this.tabs() + l);
      }
      if (frag) {
        return this._last_frag = true;
      } else {
        if ((l === "}" || l === ")") && this._tabs === 0) {
          return this._code.push("");
        }
      }
    };

    TypescriptEmitter.prototype.output_doc = function(d) {
      var line, _i, _len, _ref;
      if (d != null) {
        this.output("/**");
        _ref = d.split(/\n/);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          line = _ref[_i];
          this.output(" * " + line.replace(/^\s$/, ''));
        }
        return this.output(" */");
      }
    };

    TypescriptEmitter.prototype.emit_preface = function(_arg) {
      var infile;
      infile = _arg.infile;
      this.output("/*");
      this.output(" * Auto-generated to TypeScript by " + pkg.name + " v" + pkg.version + " (" + pkg.homepage + ")");
      this.output(" *   Input file: " + (path_lib.relative(process.cwd(), infile)));
      this.output(" */");
      return this.output("");
    };

    TypescriptEmitter.prototype.emit_imports = function(_arg) {
      var import_as, imports, path, _i, _len, _ref, _results;
      imports = _arg.imports;
      _results = [];
      for (_i = 0, _len = imports.length; _i < _len; _i++) {
        _ref = imports[_i], import_as = _ref.import_as, path = _ref.path;
        _results.push(console.log(import_as, path));
      }
      return _results;
    };

    TypescriptEmitter.prototype.emit_types = function(_arg) {
      var type, types, _i, _len, _results;
      types = _arg.types;
      _results = [];
      for (_i = 0, _len = types.length; _i < _len; _i++) {
        type = types[_i];
        _results.push(this.emit_type({
          type: type
        }));
      }
      return _results;
    };

    TypescriptEmitter.prototype.emit_type = function(_arg) {
      var go_field_suffix, nostring, type;
      type = _arg.type, go_field_suffix = _arg.go_field_suffix;
      this.output_doc(type.doc);
      switch (type.type) {
        case "record":
          if (type.typedef) {
            return this.emit_typedef(type);
          } else {
            return this.emit_record(type);
          }
          break;
        case "fixed":
          return this.emit_fixed(type);
        case "enum":
          nostring = type.go === "nostring";
          return this.emit_enum({
            t: type,
            nostring: nostring
          });
      }
    };

    TypescriptEmitter.prototype.emit_fixed = function(t) {
      return this.output("export type " + t.name + " = string | null");
    };

    TypescriptEmitter.prototype.emit_enum = function(_arg) {
      var e_name, e_num, name, nostring, s, t, _, _i, _j, _len, _ref, _ref1;
      t = _arg.t, nostring = _arg.nostring;
      name = t.name;
      this.output("enum " + name + " {");
      this.tab();
      _ref = t.symbols;
      for (_ = _i = 0, _len = _ref.length; _i < _len; _ = ++_i) {
        s = _ref[_];
        _ref1 = s.split("_"), e_name = 2 <= _ref1.length ? __slice.call(_ref1, 0, _j = _ref1.length - 1) : (_j = 0, []), e_num = _ref1[_j++];
        e_name = e_name.join("_");
        this.output("" + e_name + " = " + e_num);
      }
      this.untab();
      return this.output("}");
    };

    TypescriptEmitter.prototype.convert_primitive_type = function(m) {
      var map;
      map = {
        bool: "boolean",
        bytes: "Buffer",
        long: "number",
        float: "number",
        double: "number",
        uint: "number",
        int: "number"
      };
      return map[m] || m;
    };

    TypescriptEmitter.prototype.emit_field_type = function(t) {
      var optional, type;
      optional = false;
      type = typeof t === 'string' ? this.convert_primitive_type(t) : typeof t === 'object' ? Array.isArray(t) ? t[0] == null ? (optional = true, this.emit_field_type(t[1]).type) : "ERROR" : t.type === "array" ? this.emit_field_type(t.items).type + "[]" : t.type === "map" ? this.make_map_type({
        t: t
      }) : "ERROR" : "ERROR";
      console.log('type:', type);
      return {
        type: type,
        optional: optional
      };
    };

    TypescriptEmitter.prototype.make_map_type = function(_arg) {
      var key, t;
      t = _arg.t;
      key = t.keys != null ? this.emit_field_type(t.keys).type : "string";
      return "Map<" + key + ", " + (this.emit_field_type(t.values).type) + ">";
    };

    TypescriptEmitter.prototype.emit_typedef = function(t) {
      this.output("type " + t.name + " = " + (this.emit_field_type(t.typedef).type));
      return true;
    };

    TypescriptEmitter.prototype.emit_field = function(_arg) {
      var exported, jsonkey, mpackkey, name, optional, pointed, type, _ref;
      name = _arg.name, type = _arg.type, exported = _arg.exported, pointed = _arg.pointed, jsonkey = _arg.jsonkey, mpackkey = _arg.mpackkey;
      _ref = this.emit_field_type(type), type = _ref.type, optional = _ref.optional;
      return this.output("" + name + ": " + type);
    };

    TypescriptEmitter.prototype.emit_record = function(obj) {
      var f, _i, _len, _ref;
      this.output("type " + obj.name + " = {");
      this.tab();
      _ref = obj.fields;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        f = _ref[_i];
        console.log('f:', f);
        this.emit_field({
          name: f.name,
          type: f.type,
          exported: !(f.internal != null),
          jsonkey: f.jsonkey,
          mpackkey: f.mpackkey
        });
      }
      this.untab();
      return this.output("}");
    };

    TypescriptEmitter.prototype.run = function(_arg) {
      var infile, json, types_only;
      infile = _arg.infile, json = _arg.json, types_only = _arg.types_only;
      console.log('json:', json);
      this.emit_preface({
        infile: infile
      });
      this.emit_imports(json);
      this.emit_types(json);
      return this._code;
    };

    return TypescriptEmitter;

  })();

}).call(this);
