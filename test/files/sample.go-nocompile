// Auto-generated by avdl-compiler v1.3.9 (https://github.com/keybase/node-avdl-compiler)
//   Input file: /home/songgao/gopath/src/github.com/keybase/node-avdl-compiler/test/files/../avdl/sample.avdl

package sample1

import (
	"github.com/keybase/go-framed-msgpack-rpc/rpc"
	context "golang.org/x/net/context"
	keybase1 "github.com/keybase/client/go/protocol/keybase1"
	"errors"
)


// Joe is an alias for an int.
type Joe int
// R is a rad record.
type R struct {
	Bar	keybase1.UID	`codec:"bar" json:"bar"`
}

type Ha struct {
	TLFMessage	string	`codec:"tlfMessage" json:"tlfMessage"`
	TLFID	string	`codec:"tlfid" json:"tlfid"`
}

type Types int
const (
	Types_NONE Types = 0
	Types_BOZO Types = 1
	Types_BIPPY Types = 2
	Types_AGGLE Types = 3
	Types_FLAGGLE Types = 4
)

var TypesMap = map[string]Types{
	"NONE" : 0,
	"BOZO" : 1,
	"BIPPY" : 2,
	"AGGLE" : 3,
	"FLAGGLE" : 4,
}

var TypesRevMap = map[Types]string{
	0 : "NONE",
	1 : "BOZO",
	2 : "BIPPY",
	3 : "AGGLE",
	4 : "FLAGGLE",
}

type Boozle struct {
	Typ__	Types	`codec:"typ" json:"typ"`
	Bozo__	*int	`codec:"bozo,omitempty" json:"bozo,omitempty"`
	Bippy__	*string	`codec:"bippy,omitempty" json:"bippy,omitempty"`
	Aggle__	*[]int	`codec:"aggle,omitempty" json:"aggle,omitempty"`
	Flaggle__	*[]bool	`codec:"flaggle,omitempty" json:"flaggle,omitempty"`
	Default__	*int	`codec:"default,omitempty" json:"default,omitempty"`
}

func (o *Boozle) Typ() (ret Types, err error) {
	switch (o.Typ__) {
		case Types_BOZO:
			if o.Bozo__ == nil {
				err = errors.New("unexpected nil value for Bozo__")
				return ret, err
			}
		case Types_BIPPY:
			if o.Bippy__ == nil {
				err = errors.New("unexpected nil value for Bippy__")
				return ret, err
			}
		case Types_AGGLE:
			if o.Aggle__ == nil {
				err = errors.New("unexpected nil value for Aggle__")
				return ret, err
			}
		case Types_FLAGGLE:
			if o.Flaggle__ == nil {
				err = errors.New("unexpected nil value for Flaggle__")
				return ret, err
			}
		default:
			if o.Default__ == nil {
				err = errors.New("unexpected nil value for Default__")
				return ret, err
			}
	}
	return o.Typ__, nil
}

func (o Boozle) Bozo() int {
	if o.Typ__ != Types_BOZO {
		panic("wrong case accessed")
	}
	if o.Bozo__ == nil {
		return 0
	}
	return *o.Bozo__
}

func (o Boozle) Bippy() string {
	if o.Typ__ != Types_BIPPY {
		panic("wrong case accessed")
	}
	if o.Bippy__ == nil {
		return ""
	}
	return *o.Bippy__
}

func (o Boozle) Aggle() []int {
	if o.Typ__ != Types_AGGLE {
		panic("wrong case accessed")
	}
	if o.Aggle__ == nil {
		return []int{}
	}
	return *o.Aggle__
}

func (o Boozle) Flaggle() []bool {
	if o.Typ__ != Types_FLAGGLE {
		panic("wrong case accessed")
	}
	if o.Flaggle__ == nil {
		return []bool{}
	}
	return *o.Flaggle__
}

func (o Boozle) Default() int {
	if o.Typ__ == Types_BOZO || o.Typ__ == Types_BIPPY || o.Typ__ == Types_AGGLE || o.Typ__ == Types_FLAGGLE {
		panic("wrong case accessed")
	}
	if o.Default__ == nil {
		return 0
	}
	return *o.Default__
}

func NewBoozleWithBozo(v int) Boozle {
	return Boozle{
		Typ__ : Types_BOZO,
		Bozo__ : &v,
	}
}

func NewBoozleWithBippy(v string) Boozle {
	return Boozle{
		Typ__ : Types_BIPPY,
		Bippy__ : &v,
	}
}

func NewBoozleWithAggle(v []int) Boozle {
	return Boozle{
		Typ__ : Types_AGGLE,
		Aggle__ : &v,
	}
}

func NewBoozleWithFlaggle(v []bool) Boozle {
	return Boozle{
		Typ__ : Types_FLAGGLE,
		Flaggle__ : &v,
	}
}

func NewBoozleDefault(typ Types, v int) Boozle {
	return Boozle{
		Typ__ : typ,
		Default__ : &v,
	}
}

type Trixie struct {
	Typ__	Types	`codec:"typ" json:"typ"`
	Bippy__	*int	`codec:"bippy,omitempty" json:"bippy,omitempty"`
}

func (o *Trixie) Typ() (ret Types, err error) {
	switch (o.Typ__) {
		case Types_BIPPY:
			if o.Bippy__ == nil {
				err = errors.New("unexpected nil value for Bippy__")
				return ret, err
			}
	}
	return o.Typ__, nil
}

func (o Trixie) Bippy() int {
	if o.Typ__ != Types_BIPPY {
		panic("wrong case accessed")
	}
	if o.Bippy__ == nil {
		return 0
	}
	return *o.Bippy__
}

func NewTrixieWithNone() Trixie {
	return Trixie{
		Typ__ : Types_NONE,
	}
}

func NewTrixieWithBozo() Trixie {
	return Trixie{
		Typ__ : Types_BOZO,
	}
}

func NewTrixieWithBippy(v int) Trixie {
	return Trixie{
		Typ__ : Types_BIPPY,
		Bippy__ : &v,
	}
}

func NewTrixieWithAggle() Trixie {
	return Trixie{
		Typ__ : Types_AGGLE,
	}
}

func NewTrixieWithFlaggle() Trixie {
	return Trixie{
		Typ__ : Types_FLAGGLE,
	}
}

type Noozle struct {
	Version__	int	`codec:"version" json:"version"`
	Int1__	*string	`codec:"int1,omitempty" json:"int1,omitempty"`
	Int2__	*int	`codec:"int2,omitempty" json:"int2,omitempty"`
}

func (o *Noozle) Version() (ret int, err error) {
	switch (o.Version__) {
		case 1:
			if o.Int1__ == nil {
				err = errors.New("unexpected nil value for Int1__")
				return ret, err
			}
		case 2:
			if o.Int2__ == nil {
				err = errors.New("unexpected nil value for Int2__")
				return ret, err
			}
	}
	return o.Version__, nil
}

func (o Noozle) Int1() string {
	if o.Version__ != 1 {
		panic("wrong case accessed")
	}
	if o.Int1__ == nil {
		return ""
	}
	return *o.Int1__
}

func (o Noozle) Int2() int {
	if o.Version__ != 2 {
		panic("wrong case accessed")
	}
	if o.Int2__ == nil {
		return 0
	}
	return *o.Int2__
}

func NewNoozleWith1(v string) Noozle {
	return Noozle{
		Version__ : 1,
		Int1__ : &v,
	}
}

func NewNoozleWith2(v int) Noozle {
	return Noozle{
		Version__ : 2,
		Int2__ : &v,
	}
}

func NewNoozleDefault(version int) Noozle {
	return Noozle{
		Version__ : version,
	}
}

type Blurp struct {
	B__	bool	`codec:"b" json:"b"`
	True__	*string	`codec:"true,omitempty" json:"true,omitempty"`
	False__	*int	`codec:"false,omitempty" json:"false,omitempty"`
}

func (o *Blurp) B() (ret bool, err error) {
	switch (o.B__) {
		case true:
			if o.True__ == nil {
				err = errors.New("unexpected nil value for True__")
				return ret, err
			}
		case false:
			if o.False__ == nil {
				err = errors.New("unexpected nil value for False__")
				return ret, err
			}
	}
	return o.B__, nil
}

func (o Blurp) True() string {
	if o.B__ != true {
		panic("wrong case accessed")
	}
	if o.True__ == nil {
		return ""
	}
	return *o.True__
}

func (o Blurp) False() int {
	if o.B__ != false {
		panic("wrong case accessed")
	}
	if o.False__ == nil {
		return 0
	}
	return *o.False__
}

func NewBlurpWithTrue(v string) Blurp {
	return Blurp{
		B__ : true,
		True__ : &v,
	}
}

func NewBlurpWithFalse(v int) Blurp {
	return Blurp{
		B__ : false,
		False__ : &v,
	}
}

type GetBazArg struct {
	R	R	`codec:"r" json:"r"`
	Beep	keybase1.DeviceID	`codec:"beep" json:"beep"`
}

type NotifierArg struct {
	I	int	`codec:"i" json:"i"`
}

// SampleInterface protocol is a sample among samples.
type SampleInterface interface {
	// GetBaz will get a baz like you wouldn't believe.
	// If this baz isn't gotten, then I'll eat my hat
	// 
	// And then.
	GetBaz(context.Context, GetBazArg) (keybase1.SigID,error)
	// Notifier notifies the notifiee.
	Notifier(context.Context, int) (error)
}

func SampleProtocol(i SampleInterface) rpc.Protocol {
	return rpc.Protocol {
		Name: "sample.1.sample",
		Methods: map[string]rpc.ServeHandlerDescription{
			"getBaz": {
				MakeArg: func() interface{} {
					ret := make([]GetBazArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]GetBazArg)
					if !ok {
						err = rpc.NewTypeError((*[]GetBazArg)(nil), args)
						return
					}
					ret, err = i.GetBaz(ctx, (*typedArgs)[0])
					return
				},
				MethodType: rpc.MethodCall,
			},
			"notifier": {
				MakeArg: func() interface{} {
					ret := make([]NotifierArg, 1)
					return &ret
				},
				Handler: func(ctx context.Context, args interface{}) (ret interface{}, err error) {
					typedArgs, ok := args.(*[]NotifierArg)
					if !ok {
						err = rpc.NewTypeError((*[]NotifierArg)(nil), args)
						return
					}
					err = i.Notifier(ctx, (*typedArgs)[0].I)
					return
				},
				MethodType: rpc.MethodNotify,
			},
		},
	}
}

type SampleClient struct {
	Cli rpc.GenericClient
}

// GetBaz will get a baz like you wouldn't believe.
// If this baz isn't gotten, then I'll eat my hat
// 
// And then.
func (c SampleClient) GetBaz(ctx context.Context, __arg GetBazArg) (res keybase1.SigID,err error) {
	err = c.Cli.Call(ctx, "sample.1.sample.getBaz", []interface{}{__arg}, &res)
	return
}

// Notifier notifies the notifiee.
func (c SampleClient) Notifier(ctx context.Context, i int) (err error) {
	__arg := NotifierArg{ I : i }
	err = c.Cli.Notify(ctx, "sample.1.sample.notifier", []interface{}{__arg})
	return
}
